{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"aws-annoying","text":"<p>Utils to handle some annoying AWS tasks.</p>"},{"location":"#about","title":"\u2753 About","text":"<p>This project aims to provide a set of utilities and examples to help with some annoying tasks when working with AWS.</p> <p>Major directories of the project:</p> <ul> <li>aws_annoying Python package containing CLI and utility functions.</li> <li>console Utilities to help working with AWS Console.</li> <li>examples Examples of how to use the package.</li> </ul>"},{"location":"#installation","title":"\ud83d\ude80 Installation","text":"<p>It is recommended to use pipx to install <code>aws-annoying</code> CLI:</p> <pre><code>$ pipx install aws-annoying\n$ aws-annoying --help\n\n Usage: aws-annoying [OPTIONS] COMMAND [ARGS]...\n\n...\n</code></pre> <p>As the package also provides some utility functions, you can install <code>aws-annoying</code> via pip, if you are going to use those utils.</p>"},{"location":"#usage","title":"\ud83d\udca1 Usage","text":"<p>Refer to the CLI help or documentation for detailed information on how to use each command.</p>"},{"location":"#contributing","title":"\ud83d\udc96 Contributing","text":"<p>Any feedback, suggestions or contributions are welcome! Feel free to open an issue or a pull request.</p>"},{"location":"cli-references/ecs/","title":"ECS (Elastic Container Service)","text":""},{"location":"cli-references/ecs/#aws-annoying-ecs-task-definition-lifecycle","title":"<code>aws-annoying ecs task-definition-lifecycle</code>","text":"<p>Expire and delete ECS task definitions.</p> <p>Expire and delete ECS task definitions for a given family, keeping revisions adhering to the given constraint. You can use this command to clean up old task definitions that are no longer needed.</p> <p>Example usage:</p> <pre><code>aws-annoying ecs task-definition-lifecycle \\\n    --family &lt;task-definition-family&gt; \\\n    --keep-latest 5 \\\n    --delete\n</code></pre> Source code in <code>aws_annoying/cli/ecs/task_definition_lifecycle.py</code> <pre><code>@ecs_app.command()\ndef task_definition_lifecycle(\n    ctx: typer.Context,\n    *,\n    family: str = typer.Option(\n        ...,\n        help=\"The name of the task definition family.\",\n        show_default=False,\n    ),\n    keep_latest: int = typer.Option(\n        ...,\n        help=\"Number of latest (revision) task definitions to keep.\",\n        show_default=False,\n        min=1,\n        max=100,\n    ),\n    delete: bool = typer.Option(\n        False,  # noqa: FBT003\n        help=\"Delete the task definition after deregistering it.\",\n    ),\n) -&gt; None:\n    r\"\"\"Expire and delete ECS task definitions.\n\n    Expire and delete ECS task definitions for a given family, keeping revisions adhering to\n    the given constraint. You can use this command to clean up old task definitions that are no\n    longer needed.\n\n    Example usage:\n\n    ```shell\n    aws-annoying ecs task-definition-lifecycle \\\n        --family &lt;task-definition-family&gt; \\\n        --keep-latest 5 \\\n        --delete\n    ```\n    \"\"\"\n    dry_run = ctx.meta[\"dry_run\"]\n    ecs = boto3.client(\"ecs\")\n\n    # Get all task definitions for the family\n    response_iter = ecs.get_paginator(\"list_task_definitions\").paginate(\n        familyPrefix=family,\n        status=\"ACTIVE\",\n        sort=\"ASC\",\n    )\n    task_definition_arns = []\n    for response in response_iter:\n        task_definition_arns.extend(response[\"taskDefinitionArns\"])\n\n    # Sort by revision number\n    task_definition_arns.sort(key=lambda arn: int(arn.split(\":\")[-1]))\n\n    # Keep the latest N task definitions\n    expired_taskdef_arns = task_definition_arns[:-keep_latest]\n    logger.warning(\"Deregistering %d task definitions...\", len(expired_taskdef_arns))\n    for arn in expired_taskdef_arns:\n        if not dry_run:\n            ecs.deregister_task_definition(taskDefinition=arn)\n\n        # ARN like: \"arn:aws:ecs:&lt;region&gt;:&lt;account-id&gt;:task-definition/&lt;family&gt;:&lt;revision&gt;\"\n        _, family_revision = arn.split(\":task-definition/\")\n        logger.warning(\"Deregistered task definition [yellow]%r[/yellow]\", family_revision)\n\n    if delete and expired_taskdef_arns:\n        # Delete the expired task definitions in chunks due to API limitation\n        logger.warning(\n            \"Deleting %d task definitions in chunks of size %d...\",\n            len(expired_taskdef_arns),\n            _DELETE_CHUNK_SIZE,\n        )\n        for idx, chunk in enumerate(_chunker(expired_taskdef_arns, _DELETE_CHUNK_SIZE)):\n            if not dry_run:\n                ecs.delete_task_definitions(taskDefinitions=chunk)\n\n            logger.warning(\"Deleted %d task definitions in %d-th batch.\", len(chunk), idx)\n</code></pre>"},{"location":"cli-references/ecs/#aws-annoying-ecs-wait-for-deployment","title":"<code>aws-annoying ecs wait-for-deployment</code>","text":"<p>Wait for ECS deployment for a specific service to start, complete and stabilize.</p> <p>It's designed to be used after triggering a deployment (e.g., updating service, deploying new task definition), in conjunction with CI/CD pipelines or deployment scripts.</p> <p>Below is an example of using this command in GitHub Actions workflow:</p> <pre><code>  ...\n\n  - name: Deploy to ECS service\n    id: deploy-ecs\n    uses: aws-actions/amazon-ecs-deploy-task-definition@v2\n    with:\n      task-definition: ${{ steps.render-task-definition.outputs.task-definition }}\n      cluster: ${{ vars.AWS_ECS_CLUSTER }}\n      service: ${{ vars.AWS_ECS_SERVICE }}\n      wait-for-service-stability: false\n\n  - name: Wait for deployment complete\n    run: |\n      pipx run aws-annoying \\\n        --verbose \\\n        ecs wait-for-deployment \\\n          --cluster '${{ vars.AWS_ECS_CLUSTER }}' \\\n          --service '${{ vars.AWS_ECS_SERVICE }}' \\\n          --wait-for-start \\\n          --wait-for-stability \\\n          --timeout-seconds 600 \\\n          --expected-task-definition '${{ steps.deploy-ecs.outputs.task-definition-arn }}'\n\n  ...\n</code></pre> <p><code>--wait-for-start</code> is necessary because there could be no deployment right after the deploy action.</p> Source code in <code>aws_annoying/cli/ecs/wait_for_deployment.py</code> <pre><code>@ecs_app.command()\ndef wait_for_deployment(  # noqa: PLR0913\n    *,\n    cluster: str = typer.Option(\n        ...,\n        help=\"The name of the ECS cluster.\",\n        show_default=False,\n    ),\n    service: str = typer.Option(\n        ...,\n        help=\"The name of the ECS service.\",\n        show_default=False,\n    ),\n    expected_task_definition: Optional[str] = typer.Option(\n        None,\n        help=(\n            \"The service's task definition expected after deployment.\"\n            \" If provided, it will be used to assert the service's task definition after deployment finished or timed out.\"  # noqa: E501\n        ),\n        show_default=False,\n    ),\n    polling_interval: int = typer.Option(\n        5,\n        help=\"The interval between any polling attempts, in seconds.\",\n        min=1,\n    ),\n    timeout_seconds: Optional[int] = typer.Option(\n        None,\n        help=(\n            \"The maximum time to wait for the deployment to complete, in seconds.\"\n            \" If not provided, it will wait indefinitely.\"\n        ),\n        min=1,\n    ),\n    wait_for_start: bool = typer.Option(\n        True,  # noqa: FBT003\n        help=(\n            \"Whether to wait for the deployment to start.\"\n            \" Because there could be no deployment right after the deploy,\"\n            \" this option will wait for a new deployment to start if no running deployment is found.\"\n        ),\n    ),\n    wait_for_stability: bool = typer.Option(\n        False,  # noqa: FBT003\n        help=\"Whether to wait for the service to be stable after the deployment.\",\n    ),\n) -&gt; None:\n    r\"\"\"Wait for ECS deployment for a specific service to start, complete and stabilize.\n\n    It's designed to be used after triggering a deployment (e.g., updating service, deploying new task definition),\n    in conjunction with CI/CD pipelines or deployment scripts.\n\n    Below is an example of using this command in GitHub Actions workflow:\n\n    ```yaml\n      ...\n\n      - name: Deploy to ECS service\n        id: deploy-ecs\n        uses: aws-actions/amazon-ecs-deploy-task-definition@v2\n        with:\n          task-definition: ${{ steps.render-task-definition.outputs.task-definition }}\n          cluster: ${{ vars.AWS_ECS_CLUSTER }}\n          service: ${{ vars.AWS_ECS_SERVICE }}\n          wait-for-service-stability: false\n\n      - name: Wait for deployment complete\n        run: |\n          pipx run aws-annoying \\\n            --verbose \\\n            ecs wait-for-deployment \\\n              --cluster '${{ vars.AWS_ECS_CLUSTER }}' \\\n              --service '${{ vars.AWS_ECS_SERVICE }}' \\\n              --wait-for-start \\\n              --wait-for-stability \\\n              --timeout-seconds 600 \\\n              --expected-task-definition '${{ steps.deploy-ecs.outputs.task-definition-arn }}'\n\n      ...\n    ```\n\n    `--wait-for-start` is necessary because there could be no deployment right after the deploy action.\n    \"\"\"\n    start = datetime.now(tz=timezone.utc)\n    try:\n        with Timeout(timeout_seconds):\n            _wait_for_deployment(\n                ECSServiceRef(cluster=cluster, service=service),\n                wait_for_start=wait_for_start,\n                polling_interval=polling_interval,\n                wait_for_stability=wait_for_stability,\n                expected_task_definition=expected_task_definition,\n            )\n    except OperationTimeoutError:\n        logger.error(  # noqa: TRY400\n            \"Timeout reached after %s seconds. The deployment may not have finished.\",\n            timeout_seconds,\n        )\n        raise typer.Exit(1) from None\n    except DeploymentFailedError as err:\n        elapsed = datetime.now(tz=timezone.utc) - start\n        logger.error(  # noqa: TRY400\n            \"Deployment failed in [bold]%.2f[/bold] seconds with error: %s\",\n            elapsed.total_seconds(),\n            err,\n        )\n        raise typer.Exit(1) from None\n    else:\n        elapsed = datetime.now(tz=timezone.utc) - start\n        logger.info(\n            \"Deployment completed in [bold]%.2f[/bold] seconds.\",\n            elapsed.total_seconds(),\n        )\n</code></pre>"},{"location":"cli-references/mfa/","title":"MFA","text":""},{"location":"cli-references/mfa/#aws-annoying-mfa-configure","title":"<code>aws-annoying mfa configure</code>","text":"<p>Configure AWS profile for MFA.</p> <p>This command retrieves temporary MFA credentials using the provided source profile (<code>--mfa-source-profile</code>) and MFA token code then updates the specified AWS profile with these credentials.</p> <p>You can configure it interactively, by omitting the options, or provide them directly via command-line options.</p> <pre><code>aws-annoying mfa configure\n</code></pre> <p>If you want to use MFA as primary authentication method for an AWS profile, you can configure it to save the credentials to the default profile.</p> <pre><code>aws configure --profile mfa\naws-annoying mfa configure \\\n    --mfa-profile default \\\n    --mfa-source-profile mfa\n</code></pre> Source code in <code>aws_annoying/cli/mfa/configure.py</code> <pre><code>@mfa_app.command()\ndef configure(  # noqa: PLR0913\n    ctx: typer.Context,\n    *,\n    mfa_profile: Optional[str] = typer.Option(\n        None,\n        help=\"The MFA profile to configure.\",\n    ),\n    mfa_source_profile: Optional[str] = typer.Option(\n        None,\n        help=\"The AWS profile to use to retrieve MFA credentials.\",\n    ),\n    mfa_serial_number: Optional[str] = typer.Option(\n        None,\n        help=\"The MFA device serial number. It is required if not persisted in configuration.\",\n        show_default=False,\n    ),\n    mfa_token_code: Optional[str] = typer.Option(\n        None,\n        help=\"The MFA token code.\",\n        show_default=False,\n    ),\n    aws_credentials: Path = typer.Option(  # noqa: B008\n        \"~/.aws/credentials\",\n        help=\"The path to the AWS credentials file.\",\n    ),\n    aws_config: Path = typer.Option(  # noqa: B008\n        \"~/.aws/config\",\n        help=\"The path to the AWS config file. Used to persist the MFA configuration.\",\n    ),\n    aws_config_section: str = typer.Option(\n        \"aws-annoying:mfa\",\n        help=\"The section in the AWS config file to persist the MFA configuration.\",\n    ),\n    persist: bool = typer.Option(\n        True,  # noqa: FBT003\n        help=\"Persist the MFA configuration.\",\n    ),\n) -&gt; None:\n    r\"\"\"Configure AWS profile for MFA.\n\n    This command retrieves temporary MFA credentials using the provided source profile (`--mfa-source-profile`)\n    and MFA token code then updates the specified AWS profile with these credentials.\n\n    You can configure it interactively, by omitting the options, or provide them directly via command-line options.\n\n    ```shell\n    aws-annoying mfa configure\n    ```\n\n    If you want to use MFA as primary authentication method for an AWS profile, you can configure\n    it to save the credentials to the default profile.\n\n    ```shell\n    aws configure --profile mfa\n    aws-annoying mfa configure \\\n        --mfa-profile default \\\n        --mfa-source-profile mfa\n    ```\n    \"\"\"\n    dry_run = ctx.meta[\"dry_run\"]\n\n    # Expand user home directory\n    aws_credentials = aws_credentials.expanduser()\n    aws_config = aws_config.expanduser()\n\n    # Load configuration\n    mfa_config, exists = MfaConfig.from_ini_file(aws_config, aws_config_section)\n    if exists:\n        logger.info(\"Loaded MFA configuration from AWS config (%s).\", aws_config)\n\n    mfa_profile = (\n        mfa_profile\n        or mfa_config.mfa_profile\n        # _\n        or Prompt.ask(\"\ud83d\udc64 Enter name of MFA profile to configure\", default=\"mfa\")\n    )\n    mfa_source_profile = (\n        mfa_source_profile\n        or mfa_config.mfa_source_profile\n        or Prompt.ask(\"\ud83d\udc64 Enter AWS profile to use to retrieve MFA credentials\", default=\"default\")\n    )\n    mfa_serial_number = (\n        mfa_serial_number\n        or mfa_config.mfa_serial_number\n        # _\n        or Prompt.ask(\"\ud83d\udd12 Enter MFA serial number\")\n    )\n    mfa_token_code = (\n        mfa_token_code\n        # _\n        or Prompt.ask(\"\ud83d\udd11 Enter MFA token code\")\n    )\n\n    # Get credentials\n    logger.info(\"Retrieving MFA credentials using profile [bold]%s[/bold]\", mfa_source_profile)\n    session = boto3.session.Session(profile_name=mfa_source_profile)\n    sts = session.client(\"sts\")\n    response = sts.get_session_token(\n        SerialNumber=mfa_serial_number,\n        TokenCode=mfa_token_code,\n    )\n    credentials = response[\"Credentials\"]\n\n    # Update MFA profile in AWS credentials\n    logger.warning(\n        \"Updating MFA profile ([bold]%s[/bold]) to AWS credentials ([bold]%s[/bold])\",\n        mfa_profile,\n        aws_credentials,\n    )\n    if not dry_run:\n        update_credentials(\n            aws_credentials,\n            mfa_profile,  # type: ignore[arg-type]\n            access_key=credentials[\"AccessKeyId\"],\n            secret_key=credentials[\"SecretAccessKey\"],\n            session_token=credentials[\"SessionToken\"],\n        )\n\n    # Persist MFA configuration\n    if persist:\n        logger.info(\n            \"Persisting MFA configuration in AWS config (%s), in [bold]%s[/bold] section.\",\n            aws_config,\n            aws_config_section,\n        )\n        mfa_config.mfa_profile = mfa_profile\n        mfa_config.mfa_source_profile = mfa_source_profile\n        mfa_config.mfa_serial_number = mfa_serial_number\n        if not dry_run:\n            mfa_config.save_ini_file(aws_config, aws_config_section)\n    else:\n        logger.warning(\"MFA configuration not persisted.\")\n</code></pre>"},{"location":"cli-references/misc/","title":"Miscellaneous","text":""},{"location":"cli-references/misc/#aws-annoying-load-variables","title":"<code>aws-annoying load-variables</code>","text":"<p>Wrapper command to run command with variables from AWS resources injected as environment variables.</p> <p>This script is intended to be used in the ECS environment, where currently AWS does not support injecting whole JSON dictionary of secrets or parameters as environment variables directly.</p> <p>It first loads the variables from the AWS sources then runs the command with the variables injected as environment variables.</p> <p>In addition to <code>--arns</code> option, you can provide ARNs as the environment variables by providing <code>--env-prefix</code>. For example, if you have the following environment variables:</p> <pre><code>export LOAD_AWS_CONFIG__001_app_config=arn:aws:secretsmanager:...\nexport LOAD_AWS_CONFIG__002_db_config=arn:aws:ssm:...\n</code></pre> <p>You can run the following command:</p> <pre><code>aws-annoying load-variables --env-prefix LOAD_AWS_CONFIG__ -- ...\n</code></pre> <p>The variables are loaded in the order of option provided, overwriting the variables with the same name in the order of the ARNs. Existing environment variables are preserved by default, unless <code>--overwrite-env</code> is provided.</p> Source code in <code>aws_annoying/cli/load_variables.py</code> <pre><code>@app.command(\n    context_settings={\n        # Allow extra arguments for user provided command\n        \"allow_extra_args\": True,\n        \"ignore_unknown_options\": True,\n    },\n)\ndef load_variables(\n    ctx: typer.Context,\n    *,\n    arns: list[str] = typer.Option(\n        [],\n        metavar=\"ARN\",\n        help=(\n            \"ARNs of the secret or parameter to load.\"\n            \" The variables are loaded in the order of the ARNs,\"\n            \" overwriting the variables with the same name in the order of the ARNs.\"\n        ),\n    ),\n    env_prefix: Optional[str] = typer.Option(\n        None,\n        help=\"Prefix of the environment variables to load the ARNs from.\",\n        show_default=False,\n    ),\n    overwrite_env: bool = typer.Option(\n        False,  # noqa: FBT003\n        help=\"Overwrite the existing environment variables with the same name.\",\n    ),\n    replace: bool = typer.Option(\n        True,  # noqa: FBT003\n        help=(\n            \"Replace the current process (`os.execvpe`) with the command.\"\n            \" If disabled, run the command as a `subprocess`.\"\n        ),\n    ),\n) -&gt; NoReturn:\n    \"\"\"Wrapper command to run command with variables from AWS resources injected as environment variables.\n\n    This script is intended to be used in the ECS environment, where currently AWS does not support\n    injecting whole JSON dictionary of secrets or parameters as environment variables directly.\n\n    It first loads the variables from the AWS sources then runs the command with the variables injected as environment variables.\n\n    In addition to `--arns` option, you can provide ARNs as the environment variables by providing `--env-prefix`.\n    For example, if you have the following environment variables:\n\n    ```shell\n    export LOAD_AWS_CONFIG__001_app_config=arn:aws:secretsmanager:...\n    export LOAD_AWS_CONFIG__002_db_config=arn:aws:ssm:...\n    ```\n\n    You can run the following command:\n\n    ```shell\n    aws-annoying load-variables --env-prefix LOAD_AWS_CONFIG__ -- ...\n    ```\n\n    The variables are loaded in the order of option provided, overwriting the variables with the same name in the order of the ARNs.\n    Existing environment variables are preserved by default, unless `--overwrite-env` is provided.\n    \"\"\"  # noqa: E501\n    command = ctx.args\n    if not command:\n        logger.warning(\"No command provided. Exiting...\")\n        raise typer.Exit(0)\n\n    # Mapping of the ARNs by index (index used for ordering)\n    map_arns_by_index = {str(idx): arn for idx, arn in enumerate(arns)}\n    if env_prefix:\n        logger.info(\"Loading ARNs from environment variables with prefix: %r\", env_prefix)\n        arns_env = {\n            key.removeprefix(env_prefix): value for key, value in os.environ.items() if key.startswith(env_prefix)\n        }\n        logger.info(\"Found %d sources from environment variables.\", len(arns_env))\n        map_arns_by_index = arns_env | map_arns_by_index\n\n    # Briefly show the ARNs\n    table = Table(\"Index\", \"ARN\")\n    for idx, arn in sorted(map_arns_by_index.items()):\n        table.add_row(idx, arn)\n\n    # Workaround: The logger cannot directly handle the rich table output.\n    with StringIO() as file:\n        Console(file=file, emoji=False).print(table)\n        table_str = file.getvalue().rstrip()\n        logger.info(\"Summary:\\n%s\", table_str)\n\n    # Retrieve the variables\n    loader = VariableLoader()\n    logger.info(\"Retrieving variables from AWS resources...\")\n    try:\n        variables, load_stats = loader.load(map_arns_by_index)\n    except Exception as exc:  # noqa: BLE001\n        logger.error(\"Failed to load the variables: %s\", exc)  # noqa: TRY400\n        raise typer.Exit(1) from None\n\n    logger.info(\"Retrieved %d secrets and %d parameters.\", load_stats[\"secrets\"], load_stats[\"parameters\"])\n\n    # Prepare the environment variables\n    env = os.environ.copy()\n    if overwrite_env:\n        env.update(variables)\n    else:\n        # Update variables, preserving the existing ones\n        for key, value in variables.items():\n            env.setdefault(key, str(value))\n\n    # Run the command with the variables injected as environment variables, replacing current process\n    logger.info(\"Running the command: [bold orchid]%s[/bold orchid]\", \" \".join(command))\n    if replace:  # pragma: no cover (not coverable)\n        os.execvpe(command[0], command, env=env)  # noqa: S606\n        # The above line should never return\n\n    result = subprocess.run(command, env=env, check=False)  # noqa: S603\n    raise typer.Exit(result.returncode)\n</code></pre>"},{"location":"cli-references/session-manager/","title":"Session Manager","text":""},{"location":"cli-references/session-manager/#aws-annoying-session-manager-install","title":"<code>aws-annoying session-manager install</code>","text":"<p>Install AWS Session Manager plugin.</p> Source code in <code>aws_annoying/cli/session_manager/install.py</code> <pre><code>@session_manager_app.command()\ndef install(\n    ctx: typer.Context,\n    *,\n    yes: bool = typer.Option(\n        False,  # noqa: FBT003\n        help=\"Do not ask confirmation for installation.\",\n    ),\n) -&gt; None:\n    \"\"\"Install AWS Session Manager plugin.\"\"\"\n    dry_run = ctx.meta[\"dry_run\"]\n    session_manager = SessionManager()\n\n    # Check session-manager-plugin already installed\n    is_installed, binary_path, version = session_manager.verify_installation()\n    if is_installed:\n        logger.info(\"Session Manager plugin is already installed at %s (version: %s)\", binary_path, version)\n        return\n\n    # Install session-manager-plugin\n    logger.warning(\"Installing AWS Session Manager plugin. You could be prompted for admin privileges request.\")\n    if not dry_run:\n        session_manager.install(confirm=yes, downloader=TQDMDownloader())\n\n    # Verify installation\n    is_installed, binary_path, version = session_manager.verify_installation()\n    if not is_installed:\n        logger.error(\"Installation failed. Session Manager plugin not found.\")\n        raise typer.Exit(1)\n\n    logger.info(\"Session Manager plugin successfully installed at %s (version: %s)\", binary_path, version)\n</code></pre>"},{"location":"cli-references/session-manager/#aws-annoying-session-manager-port-forward","title":"<code>aws-annoying session-manager port-forward</code>","text":"<p>Start a port forwarding session using AWS Session Manager.</p> <p>This command allows starting a port forwarding session through an EC2 instance identified by its name or ID. If there are more than one instance with the same name, the first one found will be used.</p> <p>Also, it manages a PID file to keep track of the session manager plugin process running in background, allowing to terminate any existing process before starting a new one.</p> Source code in <code>aws_annoying/cli/session_manager/port_forward.py</code> <pre><code>@session_manager_app.command()\ndef port_forward(  # noqa: PLR0913\n    ctx: typer.Context,\n    *,\n    # TODO(lasuillard): Add `--local-host` option, redirect the traffic to non-localhost bind (unsupported by AWS)\n    local_port: int = typer.Option(\n        ...,\n        show_default=False,\n        help=\"The local port to use for port forwarding.\",\n    ),\n    through: str = typer.Option(\n        ...,\n        show_default=False,\n        help=\"The name or ID of the EC2 instance to use as a proxy for port forwarding.\",\n    ),\n    remote_host: str = typer.Option(\n        ...,\n        show_default=False,\n        help=\"The remote host to connect to.\",\n    ),\n    remote_port: int = typer.Option(\n        ...,\n        show_default=False,\n        help=\"The remote port to connect to.\",\n    ),\n    reason: str = typer.Option(\n        \"\",\n        help=\"The reason for starting the port forwarding session.\",\n    ),\n    pid_file: Path = typer.Option(  # noqa: B008\n        \"./session-manager-plugin.pid\",\n        help=\"The path to the PID file to store the process ID of the session manager plugin.\",\n    ),\n    terminate_running_process: bool = typer.Option(\n        False,  # noqa: FBT003\n        help=\"Terminate the process in the PID file if it already exists.\",\n    ),\n    log_file: Path = typer.Option(  # noqa: B008\n        \"./session-manager-plugin.log\",\n        help=\"The path to the log file to store the output of the session manager plugin.\",\n    ),\n) -&gt; None:\n    \"\"\"Start a port forwarding session using AWS Session Manager.\n\n    This command allows starting a port forwarding session through an EC2 instance identified by its name or ID.\n    If there are more than one instance with the same name, the first one found will be used.\n\n    Also, it manages a PID file to keep track of the session manager plugin process running in background,\n    allowing to terminate any existing process before starting a new one.\n    \"\"\"\n    dry_run = ctx.meta[\"dry_run\"]\n    session_manager = SessionManager()\n\n    # Check if the PID file already exists\n    if pid_file.exists():\n        if not terminate_running_process:\n            logger.error(\"PID file already exists.\")\n            raise typer.Exit(1)\n\n        pid_content = pid_file.read_text()\n        try:\n            existing_pid = int(pid_content)\n        except ValueError:\n            logger.error(\"PID file content is invalid; expected integer, but got: %r\", type(pid_content))  # noqa: TRY400\n            raise typer.Exit(1) from None\n\n        try:\n            logger.warning(\"Terminating running process with PID %d.\", existing_pid)\n            os.kill(existing_pid, signal.SIGTERM)\n            pid_file.write_text(\"\")  # Clear the PID file\n        except ProcessLookupError:\n            logger.warning(\"Tried to terminate process with PID %d but does not exist.\", existing_pid)\n\n    # Resolve the instance name or ID\n    instance_id = get_instance_id_by_name(through)\n    if instance_id:\n        logger.info(\"Instance ID resolved: [bold]%s[/bold]\", instance_id)\n        target = instance_id\n    else:\n        logger.error(\"Instance with name '%s' not found.\", through)\n        raise typer.Exit(1)\n\n    # Initiate the session\n    command = session_manager.build_command(\n        target=target,\n        document_name=\"AWS-StartPortForwardingSessionToRemoteHost\",\n        parameters={\n            \"host\": [remote_host],\n            \"portNumber\": [str(remote_port)],\n            \"localPortNumber\": [str(local_port)],\n        },\n        reason=reason,\n    )\n    stdout: subprocess._FILE\n    if log_file is not None:  # noqa: SIM108\n        stdout = log_file.open(mode=\"at+\", buffering=1)\n    else:\n        stdout = subprocess.DEVNULL\n\n    logger.info(\n        \"Starting port forwarding session through [bold]%s[/bold] with reason: [italic]%r[/italic].\",\n        through,\n        reason,\n    )\n    if not dry_run:\n        proc = subprocess.Popen(  # noqa: S603\n            command,\n            stdout=stdout,\n            stderr=subprocess.STDOUT,\n            text=True,\n            close_fds=False,  # FD inherited from parent process\n        )\n        pid = proc.pid\n    else:\n        pid = -1\n\n    logger.info(\n        \"Session Manager Plugin started with PID %d. Outputs will be logged to %s.\",\n        pid,\n        log_file.absolute(),\n    )\n\n    # Write the PID to the file\n    if not dry_run:\n        pid_file.write_text(str(pid))\n\n    logger.info(\"PID file written to %s.\", pid_file.absolute())\n</code></pre>"},{"location":"cli-references/session-manager/#aws-annoying-session-manager-start","title":"<code>aws-annoying session-manager start</code>","text":"<p>Start new session to your instance.</p> <p>You can use your EC2 instance identified by its name or ID. If there are more than one instance with the same name, the first one found will be used.</p> Source code in <code>aws_annoying/cli/session_manager/start.py</code> <pre><code>@session_manager_app.command()\ndef start(\n    ctx: typer.Context,\n    *,\n    target: str = typer.Option(\n        ...,\n        show_default=False,\n        help=\"The name or ID of the EC2 instance to connect to.\",\n    ),\n    reason: str = typer.Option(\n        \"\",\n        help=\"The reason for starting the session.\",\n    ),\n) -&gt; None:\n    \"\"\"Start new session to your instance.\n\n    You can use your EC2 instance identified by its name or ID. If there are\n    more than one instance with the same name, the first one found will be used.\n    \"\"\"\n    dry_run = ctx.meta[\"dry_run\"]\n    session_manager = SessionManager()\n\n    # Resolve the instance name or ID\n    instance_id = get_instance_id_by_name(target)\n    if instance_id:\n        logger.info(\"Instance ID resolved: [bold]%s[/bold]\", instance_id)\n        target = instance_id\n    else:\n        logger.info(\"Instance with name '%s' not found.\", target)\n        raise typer.Exit(1)\n\n    # Start the session, replacing the current process\n    logger.info(\n        \"Starting session to target [bold]%s[/bold] with reason: [italic]%r[/italic].\",\n        target,\n        reason,\n    )\n    command = session_manager.build_command(\n        target=target,\n        document_name=\"SSM-SessionManagerRunShell\",\n        parameters={},\n        reason=reason,\n    )\n    if not dry_run:\n        os.execvp(command[0], command)  # noqa: S606\n</code></pre>"},{"location":"cli-references/session-manager/#aws-annoying-session-manager-stop","title":"<code>aws-annoying session-manager stop</code>","text":"<p>Stop running session for PID file.</p> Source code in <code>aws_annoying/cli/session_manager/stop.py</code> <pre><code>@session_manager_app.command()\ndef stop(\n    ctx: typer.Context,\n    *,\n    pid_file: Path = typer.Option(  # noqa: B008\n        \"./session-manager-plugin.pid\",\n        help=\"The path to the PID file to store the process ID of the session manager plugin.\",\n    ),\n    remove: bool = typer.Option(\n        True,  # noqa: FBT003\n        help=\"Remove the PID file after stopping the session.\",\n    ),\n) -&gt; None:\n    \"\"\"Stop running session for PID file.\"\"\"\n    dry_run = ctx.meta[\"dry_run\"]\n\n    # Check if PID file exists\n    if not pid_file.is_file():\n        logger.error(\"PID file not found: %s\", pid_file)\n        raise typer.Exit(1)\n\n    # Read PID from file\n    pid_content = pid_file.read_text()\n    try:\n        pid = int(pid_content)\n    except ValueError:\n        logger.error(\"PID file content is invalid; expected integer, but got: %s\", type(pid_content))  # noqa: TRY400\n        raise typer.Exit(1) from None\n\n    # Send SIGTERM to the process\n    try:\n        logger.warning(\"Terminating running process with PID %d.\", pid)\n        if not dry_run:\n            os.kill(pid, signal.SIGTERM)\n    except ProcessLookupError:\n        logger.warning(\"Tried to terminate process with PID %d but does not exist.\", pid)\n\n    # Remove the PID file\n    if remove:\n        logger.info(\"Removed the PID file %s.\", pid_file)\n        if not dry_run:\n            pid_file.unlink()\n\n    logger.info(\"Terminated the session successfully.\")\n</code></pre>"}]}